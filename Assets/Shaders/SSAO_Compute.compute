// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel SSAO
#pragma kernel Geometry
#pragma kernel GeometryBasic
#pragma kernel deptSsao
#pragma kernel Blur
#pragma kernel Lighting

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> _Results;
RWTexture2D<float4> gAlbedo;
RWTexture2D<float4> gNormal;
RWTexture2D<float4> gPosition;

RWTexture2D<float4> Positions;
RWTexture2D<float4> depthTexture;
float noiseBuffer[48];


Texture2D<float4> _gPosition;
SamplerState sampler_gPosition;

Texture2D<float4> _gDepth;
SamplerState sampler_gDepth;

Texture2D<float4> _gNormal;
SamplerState sampler_gNormal;

Texture2D<float4> _gTex;
SamplerState sampler_gNoise;

Texture2D<float4> _gSSAO;
SamplerState sampler_gSSAO;

Texture2D<float4> _gBlur;
SamplerState sampler_gBlur;

float samples[192];

int kernelSize;
float radius;
float bias;

float4 noiseScale;
float4x4 projection;
float4x4 viewMatrix; 
float4x4 model; 
[numthreads(8,8,1)]
void SSAO (uint3 id : SV_DispatchThreadID)
{

    float3 fragPos = _gPosition.SampleLevel(sampler_gPosition, id.xy, 0).xyz;
    float3 normal = normalize(_gNormal.SampleLevel(sampler_gNormal, id.xy, 0).xyz);
    float noisePos = ((id.x / noiseScale.x) + ((id.y / noiseScale.y * 4)) *3);
    float3 randomVec = normalize(float3(noiseBuffer[noisePos ], noiseBuffer[noisePos + 1], noiseBuffer[noisePos + 2]));

    float3 tangent = normalize(randomVec - mul(normal, dot(randomVec, normal)));
    float3 bitangent = cross(normal, tangent);
    float3x3 TBN = float3x3(tangent, bitangent, normal);

    float occlusion = 0.0;

    for (int i = 0; i < kernelSize * 3; i += 3)
    {
        float3 samplePos = float3(samples[i], samples[i + 1], samples[i + 2]);
        samplePos = mul(TBN, samplePos);
        samplePos = fragPos + mul(samplePos, radius);

        float4 offset = float4(samplePos.x, samplePos.y, samplePos.z, 1.0);
        offset = mul(projection, offset);
        offset.xyz /= offset.w;
        offset.xyz = offset.xyz * 0.5 + 0.5;

        float sampleDepth = _gPosition.SampleLevel(sampler_gPosition, offset.xy, 0).z;

        float rangeCheck = smoothstep(0.0, 1.0, radius / abs(fragPos.z - sampleDepth));

        occlusion +=  (sampleDepth >= samplePos.z + bias ? 1.0 : 0.0)* rangeCheck;
    }
    occlusion = 1.0 - (occlusion / kernelSize);
    if (occlusion) {

    }
    _Results[id.xy] = float4(occlusion, occlusion, occlusion, 0.f);
  //  float3 fragPos = tex2D(sampler_gPosition, id.xy).xyz;

   // = float4(1.f, 1.f, 0.f, 0.f);
}

float gAspectRatio;
float gTanHalfFOV;
float2 ViewRay;
float2 TexCoord;

float CalcViewZ(float2 Coords)
{
    float Depth = _gDepth.SampleLevel(sampler_gDepth, Coords, 0).x;
    float ViewZ = projection[3][2] / (2 * Depth - 1 - projection[2][2]);
    return ViewZ;
}

[numthreads(8, 8, 1)]
void deptSsao(uint3 id : SV_DispatchThreadID)
{

    TexCoord = (_gPosition[id.xy].xy + float2(1.0, 1.0)) / 2.0;
    ViewRay.x = _gPosition[id.xy].x * gAspectRatio * gTanHalfFOV;
    ViewRay.y = _gPosition[id.xy].y * gTanHalfFOV;

    float ViewZ = CalcViewZ(TexCoord);

    float ViewX = ViewRay.x * ViewZ;
    float ViewY = ViewRay.y * ViewZ;

    float3 Pos = float3(ViewX, ViewY, ViewZ);


    float occlusion = 0.0;

    for (int i = 0; i < kernelSize * 3; i +=3)
    {
        float3 samplePos = Pos + float3(samples[i], samples[i + 1], samples[i + 2]);
        float4 offset = float4(samplePos.x, samplePos.y, samplePos.z, 1.0);
        offset = mul(projection, offset);
        offset.xy /= offset.w;
        offset.xy = offset.xy * 0.5 + float2(0.5, 0.5);

        float sampleDepth = CalcViewZ(offset.xy);

        if (abs(Pos.z - sampleDepth) < radius) {
            occlusion += step(sampleDepth, samplePos.z);
          //  occlusion += samplePos.z;
        }
    }
    occlusion = 1.0 - (occlusion / kernelSize);
    float powValue = occlusion;// pow(occlusion, 2.0);

    _Results[id.xy] = float4(powValue, powValue, powValue, powValue);//float4(occlusion, 1.f, 0.f, 0.f);
  //  float3 fragPos = tex2D(sampler_gPosition, id.xy).xyz;

   // = float4(1.f, 1.f, 0.f, 0.f);
}

[numthreads(8, 8, 1)]
void Geometry(uint3 id : SV_DispatchThreadID)
{
    float4x4 clipSpace = mul(projection, viewMatrix);
    float4 pos = depthTexture[id.xy];
    Positions[id.xy] = mul(clipSpace, float4(pos.x, pos.y, pos.z, 1.f));
}

[numthreads(8, 8, 1)]
void GeometryBasic(uint3 id : SV_DispatchThreadID)
{
    float4 viewPos = mul(mul(viewMatrix, model), float4(depthTexture[id.xy].xyz, 1.f));

    float3 FragPos = viewPos.xyz;

    float3x3 normalMatrix = mul(viewMatrix, model);
    normalMatrix = transpose(normalMatrix);
    float3 Normal = mul(normalMatrix, (false ? -depthTexture[id.xy].xyz : depthTexture[id.xy].xyz));
    gPosition[id.xy] = float4(FragPos, 1.f);
    gNormal[id.xy] = float4(normalize(Normal), 1.f);
    gAlbedo[id.xy] = float4(0.95, 0.95, 0.95, 0.f);
}

float Offsets[4] = { -1.5, -0.5, 0.5, 1.5 };
[numthreads(8, 8, 1)]
void Blur(uint3 id : SV_DispatchThreadID)
{
    TexCoord = (_gPosition[id.xy].xy + float2(1.0, 1.0)) / 2.0;
    float3 Color = float3(0.0, 0.0, 0.0);

    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            float2 tc = TexCoord;
            float width;
            float height;
            uint level;
            _gSSAO.GetDimensions(0, width, height, level);
            tc.x = TexCoord.x + Offsets[j] / width;
            tc.y = TexCoord.y + Offsets[i] / height;
            Color += _gSSAO.SampleLevel(sampler_gSSAO, tc, 0).xyz;
        }
    }

    Color /= 16.0;

    _Results[id.xy] = float4(Color.x, Color.y, Color.z, 1.0);
}


float3 Normal0;
float3 WorldPos0;
float2 CalcScreenTexCoord(uint3 id)
{
    return Positions[id.xy].xy;
}

float3 Color;
float AmbientIntensity;
float DiffuseIntensity;
float4 Direction;
float3 lightPosition;

float lightLinear = 0.09;
float lightQuadratic = 0.032;

float gSpecularPower;
float gMatSpecularIntensity;
float3 gEyeWorldPos;

float4 CalcLightInternal(float3 Normal, uint3 id)
{
    float4 AmbientColor = float4(Color, 1.0f) * AmbientIntensity;


    AmbientColor *= _gBlur.SampleLevel(sampler_gBlur, id.xy, 0).x;

    float DiffuseFactor = dot(Normal, -Direction.xyz);

    float4 DiffuseColor = float4(0, 0, 0, 0);
    float4 SpecularColor = float4(0, 0, 0, 0);

    if (DiffuseFactor > 0) {
        DiffuseColor = float4(Color, 1.0f) * DiffuseIntensity * DiffuseFactor;

        //float3 VertexToEye = normalize(gEyeWorldPos - WorldPos0);
        //float3 LightReflect = normalize(reflect(LightDirection, Normal));
        //float SpecularFactor = dot(VertexToEye, LightReflect);
        //SpecularFactor = pow(SpecularFactor, gSpecularPower);
        //if (SpecularFactor > 0) {
        //    SpecularColor = float3(Light.Color, 1.0f) *
        //        gMatSpecularIntensity * SpecularFactor;
        //}
    }

    return (AmbientColor + DiffuseColor + SpecularColor);
}


[numthreads(8, 8, 1)]
void Lighting(uint3 id : SV_DispatchThreadID)
{

    float4x4 clipSpace = mul(projection, viewMatrix);
    float3 FragPos = _gPosition[id.xy].xyz;
    //TexCoord = mul(float4(Position.x, Position.y, Position.z, 1.0), clipSpace );
    Normal0 = (float4(depthTexture[id.xy].x, depthTexture[id.xy].y, depthTexture[id.xy].z, 0.0)).xyz;
    WorldPos0 = (float4(FragPos.x, FragPos.y, FragPos.z, 1.0)).xyz;

    float AmbientOcclusion = _gBlur.SampleLevel(sampler_gBlur, FragPos.xy, 0).x;

    float3 ambient = float3(0.3 * FragPos * AmbientOcclusion);
    float3 lighting = ambient;
    float3 viewDir = normalize(-FragPos);

    float3 Normal = _gDepth.SampleLevel(sampler_gDepth, FragPos.xy, 0);

    // diffuse
    float3 lightDir = Direction.xyz;//normalize(lightPosition - FragPos.xyz);
    float3 diffuse = max(dot(Normal, lightDir), 0.0) * FragPos * Color;
    // specular
    float3 halfwayDir = normalize(lightDir + viewDir);
    float spec = pow(max(dot(Normal, halfwayDir), 0.0), 8.0);
    float3 specular = Color * spec;

    float distance = length(lightPosition - FragPos);
    float attenuation = 1.0 / (1.0 + lightLinear * distance + lightQuadratic * distance * distance);

    diffuse *= attenuation;
    specular *= attenuation;
    lighting += diffuse + specular;

    //float3 Normal = normalize(Normal0);
    //float4 TotalLight = CalcLightInternal(Normal, id);

    //if (gShaderType == SHADER_TYPE_ONLY_AO) {
    //    FragColor = vec4(texture(gAOMap, CalcScreenTexCoord()).x);
    //}
    //else {
    //}

    //_Results[id.xy] = _gPosition.SampleLevel(sampler_gPosition, id.xy, 0) * TotalLight;
    _Results[id.xy] = float4(lighting.x, lighting.y, lighting.z, 1.f);
}
