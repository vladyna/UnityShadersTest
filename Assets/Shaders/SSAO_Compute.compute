#include "UnityCG.cginc"
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel SSAO


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> _Results;

Texture2D<float4> _gPosition;
SamplerState sampler_gPosition;

Texture2D<float4> _noiseTexture;
SamplerState sampler_noiseTexture;

Texture2D _gNormal;
SamplerState sampler_gNormal;


float noiseBuffer[48];
float samples[192];

int kernelSize;
float radius;
float bias;

float4 noiseScale;
float4x4 projection;
float4x4 viewMatrix; 
float4x4 model; 
float gAspectRatio;

[numthreads(8,1,1)]
void SSAO (uint3 id : SV_DispatchThreadID)
{
    float2 TexCoord = _gPosition[id.xy];// (id.x, id.y);// + float2(1.0, 1.0)) / 2.0;
    float3 fragPos = _gPosition.SampleLevel(sampler_gPosition, TexCoord, 0).xyz;
    float3 normal = normalize(_gNormal.SampleLevel(sampler_gNormal, TexCoord, 0).xyz);
    //float noisePos = ((id.x / noiseScale.x) + ((id.y / noiseScale.y * 3)) *3);
    //float3 randomVec = normalize(float3(noiseBuffer[noisePos ], noiseBuffer[noisePos + 1], noiseBuffer[noisePos + 2]));
    float3 randomVec = normalize(_noiseTexture.SampleLevel(sampler_noiseTexture, TexCoord * noiseScale, 0).xyz);
    float3 tangent = normalize(randomVec - mul(normal, dot(randomVec, normal)));
    float3 bitangent = cross(normal, tangent);
    float3x3 TBN = float3x3(tangent, bitangent, normal);

    float occlusion = 0.0;

    for (int i = 0; i < kernelSize * 3; i += 3)
    {
        float3 samplePos = float3(samples[i], samples[i + 1], samples[i + 2]);
        samplePos = mul(TBN, samplePos);
        samplePos = fragPos + mul(samplePos, radius);

        float4 offset = float4(samplePos.x, samplePos.y, samplePos.z, 1.0);
        offset = mul(projection, offset);
        offset.xyz /= offset.w;
        offset.xyz = offset.xyz * 0.5 + 0.5;

        float sampleDepth = _gPosition.SampleLevel(sampler_gPosition, offset.xy, 0).z;

        float rangeCheck = smoothstep(0.0, 1.0, radius / abs(fragPos.z - sampleDepth));

        occlusion += (sampleDepth >= samplePos.z + bias ? 1.0 : 0.0)* rangeCheck;

    }
    occlusion = 1.0 - (occlusion / kernelSize);
    _Results[id.xy] = float4(occlusion, occlusion, occlusion, occlusion);

}

