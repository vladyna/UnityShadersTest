#include "UnityCG.cginc"
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel SSAO


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> _Results;

Texture2D<float4> _gPosition;
SamplerState sampler_gPosition;

Texture2D<float4> _noiseTexture;
SamplerState sampler_noiseTexture;

Texture2D _gNormal;
SamplerState sampler_gNormal;

Texture2D _gDiffuse;
SamplerState sampler_gDiffuse;

float noiseBuffer[48];
float samples[192];

int kernelSize;
float radius;
float bias;
float intensity;
float4 noiseScale;
float4x4 projection;
float4x4 viewMatrix; 
float4x4 model; 
float screenWidth;
float screenHeight;

float _Step;

float2 GetUV(uint3 id) {
    return (id.xy + 0.5) * _Step - 1.0;
}
[numthreads(8,8,1)]
void SSAO (uint3 id : SV_DispatchThreadID)
{
    float4 NormalDepth = float4(0, 0, 0, 0);
    float2 TexCoord = float2((float)id.x / (float)screenWidth, (float)id.y / (float)screenHeight);
    DecodeDepthNormal(_gNormal.SampleLevel(sampler_gNormal, TexCoord, 0), NormalDepth.w, NormalDepth.xyz);
    float3 fragPos = _gPosition.SampleLevel(sampler_gPosition, TexCoord, 0).xyz;
    float3 normal = normalize(NormalDepth.xyz);//normalize(_gNormal.SampleLevel(sampler_gNormal, TexCoord, 0).xyz);
    //float noisePos = ((id.x / noiseScale.x) + ((id.y / noiseScale.y * 3)) *3);
    //float3 randomVec = normalize(float3(noiseBuffer[noisePos ], noiseBuffer[noisePos + 1], noiseBuffer[noisePos + 2]));
    float3 randomVec = normalize(_noiseTexture.SampleLevel(sampler_noiseTexture, TexCoord * noiseScale, 0).xyz);
    float3 tangent = normalize(randomVec - mul(normal, dot(randomVec, normal)));
    float3 bitangent = cross(normal, tangent);
    float3x3 TBN = float3x3(tangent, bitangent, normal);

    float occlusion = 0.0;

    for (int i = 0; i < kernelSize * 3; i += 3)
    {
        float3 samplePos = float3(samples[i], samples[i + 1], samples[i + 2]);
        samplePos = mul(TBN, samplePos);
        samplePos = fragPos + mul(samplePos, radius);

        float4 offset = float4(samplePos.x, samplePos.y, samplePos.z, 1.0);
        offset = mul(projection, offset);
        offset.xyz /= offset.w;
        offset.xyz = offset.xyz * 0.5 + 0.5;

        float sampleDepth = _gPosition.SampleLevel(sampler_gPosition, offset.xy, 0).z;

        float rangeCheck = smoothstep(0.0, 1.0, radius / abs(fragPos.z - sampleDepth));

        occlusion += (sampleDepth >= samplePos.z + bias ? 1.0 : 0.0)* rangeCheck;

    }
    occlusion = 1.0 - (occlusion / kernelSize) * intensity;
    _Results[id.xy] = float4(occlusion, occlusion, occlusion, occlusion);
    //_Results[id.xy] = float4(TexCoord.x, TexCoord.y, 0.f, 1.0f);//_gDiffuse.SampleLevel(sampler_gDiffuse, TexCoord, 0).xyz * occlusion;// 
    //_Results[id.xy] = tex2D(_GlowMap, id.xy);

}

